/*
 * This is the Loris C++ Class Library, implementing analysis, 
 * manipulation, and synthesis of digitized sounds using the Reassigned 
 * Bandwidth-Enhanced Additive Sound Model.
 *
 * Loris is Copyright (c) 1999-2010, 2014 by Kelly Fitz and Lippold Haken and Tomas medek
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY, without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * RealTimeSynthesizer.C
 *
 * Implementation of class Loris::RealTimeSynthesizer, a synthesizer of
 * bandwidth-enhanced Partials.
 *
 * Tomas Medek, 24 Jul 20149
 * tom@virtualanalogy.org
 *
 *
 */
#if HAVE_CONFIG_H
    #include "config.h"
#endif
#include "RealtimeSynthesizer.h"
#include "Oscillator.h"
#include "Breakpoint.h"
#include "BreakpointUtils.h"
#include "Envelope.h"
#include "LorisExceptions.h"
#include "Notifier.h"
#include "Partial.h"
#include "Resampler.h"
#include "phasefix.h"

#include <algorithm>
#include <cmath>
#include <assert.h>

//  begin namespace
namespace Loris {
// ---------------------------------------------------------------------------
//  Synthesizer constructor
// ---------------------------------------------------------------------------
//!	Construct a Synthesizer using the default parameters and sample
//!	buffer (a standard library vector). Since Partials generated by the 
//! Loris Analyzer generally begin and end at non-zero amplitude, zero-amplitude
//!	Breakpoints are inserted at either end of the Partial, at a temporal
//!	distance equal to the fade time, to reduce turn-on and turn-off
//!	artifacts.
//!
//! \sa Synthesizer::Parameters
//!
//!	\param	buffer The vector (of doubles) into which rendered samples
//!			   should be accumulated.
//!	\throw	InvalidArgument if any of the parameters is invalid.
RealTimeSynthesizer::RealTimeSynthesizer( std::vector<double> & buffer ) :
    Synthesizer( buffer )
{

}
// ---------------------------------------------------------------------------
//  RealTimeSynthesizer constructor
// ---------------------------------------------------------------------------
//!	Construct a RealTimeSynthesizer using the specified parameters and sample
//!	buffer (a standard library vector). Since Partials generated by the 
//! Loris Analyzer generally begin and end at non-zero amplitude, zero-amplitude
//!	Breakpoints are inserted at either end of the Partial, at a temporal
//!	distance equal to the fade time, to reduce turn-on and turn-off
//!	artifacts. If the fade time is unspecified, the default value of one
//!	millisecond (0.001 seconds) is used.
//!
//!	\param	params A Parameters struct storing the configuration of 
//!             RealTimeSynthesizer parameters.
//!	\param	buffer The vector (of doubles) into which rendered samples
//!			   should be accumulated.
//!	\throw	InvalidArgument if any of the parameters is invalid.
//
RealTimeSynthesizer::RealTimeSynthesizer( Parameters params, std::vector<double> & buffer ) :
    Synthesizer( params, buffer )
{

}
// ---------------------------------------------------------------------------
//  RealTimeSynthesizer constructor
// ---------------------------------------------------------------------------
//!	Construct a RealTimeSynthesizer using the specified sampling rate, sample
//!	buffer (a standard library vector), and the default fade time 
//!	stored in the DefaultParameters. Since Partials generated by the Loris 
//!	Analyzer generally begin and end at non-zero amplitude, zero-amplitude
//!	Breakpoints are inserted at either end of the Partial, at a temporal
//!	distance equal to the fade time, to reduce turn-on and turn-off
//!	artifacts.
//!
//!	\param	srate The rate (Hz) at which to synthesize samples
//!			   (must be positive).
//!	\param	buffer The vector (of doubles) into which rendered samples
//!			   should be accumulated.
//!	\throw	InvalidArgument if the specfied sample rate is non-positive.
RealTimeSynthesizer::RealTimeSynthesizer( double samplerate, std::vector<double> & buffer ) :
    Synthesizer( samplerate, buffer )
{

}
// ---------------------------------------------------------------------------
//  RealTimeSynthesizer constructor
// ---------------------------------------------------------------------------
//! Construct a RealTimeSynthesizer using the specified sampling rate, sample
//! buffer (a standard library vector), and Partial
//! fade time (in seconds). Since Partials generated by the Loris Analyzer
//! generally begin and end at non-zero amplitude, zero-amplitude
//! Breakpoints are inserted at either end of the Partial, at a temporal
//! distance equal to the fade time, to reduce turn-on and turn-off
//! artifacts. If the fade time is unspecified, the default value of one
//! millisecond (0.001 seconds) is used.
//!
//! \param  samplerate The rate (Hz) at which to synthesize samples
//!         (must be positive).
//! \param  buffer The vector (of doubles) into which rendered samples
//!         should be accumulated.
//! \param  fade The Partial fade time in seconds (must be non-negative).
//! \throw  InvalidArgument if the specfied sample rate is non-positive.
//! \throw  InvalidArgument if the specified fade time is negative.
RealTimeSynthesizer::RealTimeSynthesizer( double samplerate, std::vector<double> & buffer,
                          double fade ) :
    Synthesizer( samplerate, buffer, fade )
{

}

// ---------------------------------------------------------------------------    
void RealTimeSynthesizer::setup(PartialList & partials)
{
    this->partials.clear();
    clearPartialsBeingProcessed();
    
    // assuming I am getting sorted partials by time
    for (auto it : partials)
    {
        if (it.numBreakpoints() <= 0) continue;
        
        PartialStruct pStruct;
        
        pStruct.numBreakpoints = it.numBreakpoints() + 2;// + fade in + fade out
        pStruct.breakpoints.reserve(pStruct.numBreakpoints);
        
        pStruct.startTime = ( m_fadeTimeSec < it.startTime() ) ? ( it.startTime() - m_fadeTimeSec ) : 0.;// compute fade in bp time
        pStruct.endTime = it.endTime() + m_fadeTimeSec;// compute fade out bp time
        pStruct.duration = pStruct.endTime - pStruct.startTime;// new duration based on fade in and out
        
        Partial::const_iterator jt = it.begin();
        // fade in breakpoint, compute fade in time
        pStruct.breakpoints.push_back(std::make_pair(pStruct.startTime, BreakpointUtils::makeNullBefore( jt.breakpoint(), it.startTime() - pStruct.startTime)));
        for (; jt != it.end(); jt++)
        {
            pStruct.breakpoints.push_back(std::make_pair(jt.time(), jt.breakpoint()));
        }
        
        // fade out breakpoint
        jt--;
        pStruct.breakpoints.push_back(std::make_pair(jt.time() + m_fadeTimeSec, BreakpointUtils::makeNullAfter( jt.breakpoint(), m_fadeTimeSec )));
        
        this->partials.push_back(pStruct);
    }
    
    setSampleRate(sampleRate());// set sample rate specific stuff
    prepareForNote(1.0);
}

// ---------------------------------------------------------------------------
void RealTimeSynthesizer::setSampleRate(double rate)
{
    Synthesizer::setSampleRate(rate);

    //  better to compute this only once:
    OneOverSrate = 1. / m_srateHz;
    
    if (partials.empty()) return;
    
    //	grow the sample buffer, if necessary, to accommodate the latest
    //  Partial, with the fade time tacked on the end
    // Partials have to be sorted by start time!!!
    double duration = partials.back().endTime;
    
    // resize buffer to contain all samples
    typedef std::vector< double >::size_type Sz_Type;
    Sz_Type Nsamps = 1 + Sz_Type( duration * m_srateHz );
    if ( m_sampleBuffer->size() < Nsamps )
    {
        m_sampleBuffer->resize( Nsamps );
    }
}
    
// ---------------------------------------------------------------------------
void RealTimeSynthesizer::prepareForNote(double freqScale)
{
    partialIdx = 0;
    processedSamples = 0;
    clearPartialsBeingProcessed();
    
    // clear buffer - optimized version
    memset(m_sampleBuffer->data(), 0, m_sampleBuffer->size() * sizeof(decltype(*m_sampleBuffer->data())));
    
    // init partials
    int sizeP = partials.size();
    for (int i = 0; i < sizeP; i++)
    {
        // setup first breakpoint
        partials[i].state.currentSamp = index_type( (partials[i].startTime * m_srateHz) + 0.5 );   //  cheap rounding
        partials[i].state.lastBreakpoint = PartialStruct::NoBreakpointProcessed;
        
        int sizeB = partials[i].breakpoints.size();
        double endPhase = 0; // first is null breakpoint
        for (int j = 0; j < sizeB; j++)
        {
            double newFrequency = partials[i].breakpoints[j].second._frequency *= freqScale;// pitch shifting
            partials[i].breakpoints[j].second._phase = endPhase; // synchronize phase with previous wave (beginig is previous ending)
            
            //  calculate end phase which will be beginig for the next one
            if (j + 1 < sizeB)
                endPhase = wrapPi( 2. * Pi * (partials[i].breakpoints[j + 1].first - partials[i].breakpoints[j].first) * newFrequency + partials[i].breakpoints[j].second._phase);
        }
        
        //  cache the previous frequency (in Hz) so that it
        //  can be used to reset the phase when necessary
        partials[i].state.prevFrequency = partials[i].breakpoints[1].second._frequency;// 0 is null breakpoint
    }
}


// ---------------------------------------------------------------------------
void RealTimeSynthesizer::synthesizeNext( int samples )
{
    int size = partialsBeingProcessed.size();
    processedSamples += samples;
    PartialStruct *partial;
    
    // partials being processed
    for (int i = 0; i < size; i++)
    {
        partial = partialsBeingProcessed.front();
        synthesize( *partial, samples );
        
        if ( partial->state.lastBreakpoint < partial->numBreakpoints - 1)
            partialsBeingProcessed.push( partial );
        
        partialsBeingProcessed.pop();
    }
    
    // partials to be processed
    int partialSize = partials.size();
    for (; partialIdx < partialSize; partialIdx++)
    {
        partial = &(partials[partialIdx]);
        if (partial->state.currentSamp > processedSamples)
            break;
        synthesize( *partial, samples );
        
        if ( partial->state.lastBreakpoint < partial->numBreakpoints - 1)
            partialsBeingProcessed.push(partial);
        
    }
}
    
// ---------------------------------------------------------------------------
//  synthesize
// ---------------------------------------------------------------------------
//! Synthesize a bandwidth-enhanced sinusoidal Partial. Zero-amplitude
//! Breakpoints are inserted at either end of the Partial to reduce
//! turn-on and turn-off artifacts, as described above. The synthesizer
//! will resize the buffer as necessary to accommodate all the samples,
//! including the fade out. Previous contents of the buffer are not
//! overwritten. Partials with start times earlier than the Partial fade
//! time will have shorter onset fades. Partials are not rendered at
//! frequencies above the half-sample rate. 
//!
//! \param  p The Partial to synthesize.
//! \return Nothing.
//! \pre    The partial must have non-negative start time.
//! \post   This RealTimeSynthesizer's sample buffer (vector) has been 
//!         resized to accommodate the entire duration of the 
//!         Partial, p, including fade out at the end.
//! \throw  InvalidPartial if the Partial has negative start time.
//  
void
    RealTimeSynthesizer::synthesize( PartialStruct &p, const int samples)
{
    if ( p.numBreakpoints <= 0 || p.startTime < 0 )
        return;
    
    if ( p.state.lastBreakpoint >= p.numBreakpoints - 1 )// || p.breakpoints[p.state.lastBreakpoint].first > endTime) )
        return;

    m_osc.resetEnvelopes( p.breakpoints[p.state.lastBreakpoint].second, m_srateHz );
        
    //  synthesize linear-frequency segments until 
    //  there aren't any more Breakpoints to make segments:
    bufferBegin = &( m_sampleBuffer->front() );
    const Breakpoint *bp;
    int sampleCounter = 0;
    int i;
    for (i = p.state.lastBreakpoint + 1;  i < p.numBreakpoints; ++i )
    {
        tgtSamp = index_type( (p.breakpoints[i].first * m_srateHz) + 0.5 );   //  cheap rounding
        Assert( tgtSamp >= p.state.currentSamp );
        
        bp = &(p.breakpoints[i].second);
        //  if the current oscillator amplitude is
        //  zero, and the target Breakpoint amplitude
        //  is not, reset the oscillator phase so that
        //  it matches exactly the target Breakpoint 
        //  phase at tgtSamp:
        if ( m_osc.amplitude() == 0. )
        {
            //  recompute the phase so that it is correct
            //  at the target Breakpoint (need to do this
            //  because the null Breakpoint phase was computed
            //  from an interval in seconds, not samples, so
            //  it might be inaccurate):
            //
            //  double favg = 0.5 * ( prevFrequency + it.breakpoint().frequency() );
            //  double dphase = 2 * Pi * favg * ( tgtSamp - currentSamp ) / m_srateHz;
            //
            dphase = Pi * ( p.state.prevFrequency + bp->frequency() )
                               * ( tgtSamp - p.state.currentSamp ) * OneOverSrate;
            m_osc.setPhase( bp->phase() - dphase );
        }
        
        m_osc.oscillate( bufferBegin + p.state.currentSamp, bufferBegin + tgtSamp, *bp, m_srateHz );
        
        sampleCounter += tgtSamp - p.state.currentSamp;
        p.state.currentSamp = tgtSamp;
        
        //  remember the frequency, may need it to reset the 
        //  phase if a Null Breakpoint is encountered:
        p.state.prevFrequency = bp->frequency();
        
        if (sampleCounter >= samples)
            break;
    }
    
    p.state.lastBreakpoint = i;
}
    
}   //  end of namespace Loris
